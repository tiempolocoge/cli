package download

import (
	"errors"
	"fmt"
	"path/filepath"

	"github.com/MakeNowJust/heredoc"
	"github.com/cli/cli/pkg/cmdutil"
	"github.com/cli/cli/pkg/iostreams"
	"github.com/spf13/cobra"
)

type DownloadOptions struct {
	IO       *iostreams.IOStreams
	Platform platform

	RunID          string
	DestinationDir string
	FilePatterns   []string
}

type platform interface {
	List(runID string) ([]Artifact, error)
	Download(url string, dir string) error
}

func NewCmdDownload(f *cmdutil.Factory, runF func(*DownloadOptions) error) *cobra.Command {
	opts := &DownloadOptions{
		IO: f.IOStreams,
	}

	cmd := &cobra.Command{
		Use:   "download [<run-id>]",
		Short: "Download artifacts generated by a workflow run",
		Args:  cobra.MaximumNArgs(1),
		Example: heredoc.Doc(`
		  # Download all artifacts generated by a workflow run
		  $ gh run download <run-id>

		  # Download a specific artifact within a run
		  $ gh run download <run-id> -p <name>

		  # Download specific artifacts across all runs in a repository
		  $ gh run download -p <name1> -p <name2>
		`),
		RunE: func(cmd *cobra.Command, args []string) error {
			if len(args) > 0 {
				opts.RunID = args[0]
			} else if len(opts.FilePatterns) == 0 {
				return &cmdutil.FlagError{Err: errors.New("either run ID or `--pattern` is required")}
			}

			// support `-R, --repo` override
			baseRepo, err := f.BaseRepo()
			if err != nil {
				return err
			}
			httpClient, err := f.HttpClient()
			if err != nil {
				return err
			}
			opts.Platform = &apiPlatform{
				client: httpClient,
				repo:   baseRepo,
			}

			if runF != nil {
				return runF(opts)
			}
			return runDownload(opts)
		},
	}

	cmd.Flags().StringVarP(&opts.DestinationDir, "dir", "D", ".", "The directory to download artifacts into")
	cmd.Flags().StringArrayVarP(&opts.FilePatterns, "pattern", "p", nil, "Download only artifacts that match a glob pattern")

	return cmd
}

func runDownload(opts *DownloadOptions) error {
	opts.IO.StartProgressIndicator()
	defer opts.IO.StopProgressIndicator()

	artifacts, err := opts.Platform.List(opts.RunID)
	if err != nil {
		return fmt.Errorf("error fetching artifacts: %w", err)
	}

	// track downloaded artifacts and avoid re-downloading any of the same name
	downloaded := map[string]struct{}{}
	numArtifacts := 0

	for _, a := range artifacts {
		if a.Expired {
			continue
		}
		numArtifacts++
		if _, found := downloaded[a.Name]; found {
			continue
		}
		if len(opts.FilePatterns) > 0 && !matchAny(opts.FilePatterns, a.Name) {
			continue
		}
		err := opts.Platform.Download(a.DownloadURL, opts.DestinationDir)
		if err != nil {
			return fmt.Errorf("error downloading %s: %w", a.Name, err)
		}
		downloaded[a.Name] = struct{}{}
	}

	if numArtifacts == 0 {
		return errors.New("no valid artifacts found to download")
	}
	if len(downloaded) == 0 {
		return errors.New("no artifact matches any of the patterns provided")
	}

	return nil
}

func matchAny(patterns []string, name string) bool {
	for _, p := range patterns {
		if isMatch, err := filepath.Match(p, name); err == nil && isMatch {
			return true
		}
	}
	return false
}
